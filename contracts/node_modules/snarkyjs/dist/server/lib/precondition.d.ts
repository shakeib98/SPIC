import { AsFieldElements, Bool, Field, Types } from '../snarky';
import { PublicKey } from './signature';
import { Party, Preconditions } from './party';
import { UInt32, UInt64 } from './int';
export { preconditions, Account, Network, assertPreconditionInvariants, cleanPreconditionsCache, AccountValue, NetworkValue, };
declare function preconditions(party: Party, isSelf: boolean): {
    account: PreconditionClassType<AccountPrecondition>;
    network: PreconditionClassType<{
        snarkedLedgerHash: {
            isSome: Bool;
            value: Field;
        };
        timestamp: {
            lower: Types.UInt64;
            upper: Types.UInt64;
        };
        blockchainLength: {
            lower: Types.UInt32;
            upper: Types.UInt32;
        };
        minWindowDensity: {
            lower: Types.UInt32;
            upper: Types.UInt32;
        };
        totalCurrency: {
            lower: Types.UInt64;
            upper: Types.UInt64;
        };
        globalSlotSinceHardFork: {
            lower: Types.UInt32;
            upper: Types.UInt32;
        };
        globalSlotSinceGenesis: {
            lower: Types.UInt32;
            upper: Types.UInt32;
        };
        stakingEpochData: {
            ledger: {
                hash: {
                    isSome: Bool;
                    value: Field;
                };
                totalCurrency: {
                    lower: Types.UInt64;
                    upper: Types.UInt64;
                };
            };
            seed: {
                isSome: Bool;
                value: Field;
            };
            startCheckpoint: {
                isSome: Bool;
                value: Field;
            };
            lockCheckpoint: {
                isSome: Bool;
                value: Field;
            };
            epochLength: {
                lower: Types.UInt32;
                upper: Types.UInt32;
            };
        };
        nextEpochData: {
            ledger: {
                hash: {
                    isSome: Bool;
                    value: Field;
                };
                totalCurrency: {
                    lower: Types.UInt64;
                    upper: Types.UInt64;
                };
            };
            seed: {
                isSome: Bool;
                value: Field;
            };
            startCheckpoint: {
                isSome: Bool;
                value: Field;
            };
            lockCheckpoint: {
                isSome: Bool;
                value: Field;
            };
            epochLength: {
                lower: Types.UInt32;
                upper: Types.UInt32;
            };
        };
    }>;
};
declare function Network(party: Party): Network;
declare function Account(party: Party): Account;
declare function cleanPreconditionsCache(party: Party): void;
declare function assertPreconditionInvariants(party: Party): void;
declare type NetworkPrecondition = Preconditions['network'];
declare type NetworkValue = PreconditionBaseTypes<NetworkPrecondition>;
declare type Network = PreconditionClassType<NetworkPrecondition>;
declare type AccountPrecondition = Omit<Preconditions['account'], 'state'>;
declare type AccountValue = PreconditionBaseTypes<AccountPrecondition>;
declare type Account = PreconditionClassType<AccountPrecondition>;
declare type PreconditionBaseTypes<T> = {
    [K in keyof T]: T[K] extends RangeCondition<infer U> ? BasicToFull<U> : T[K] extends FlaggedOptionCondition<infer U> ? BasicToFull<U> : T[K] extends AsFieldElements<infer U> ? BasicToFull<U> : PreconditionBaseTypes<T[K]>;
};
declare type PreconditionSubclassType<U> = {
    get(): BasicToFull<U>;
    assertEquals(value: BasicToFull<U>): void;
    assertNothing(): void;
};
declare type PreconditionClassType<T> = {
    [K in keyof T]: T[K] extends RangeCondition<infer U> ? PreconditionSubclassType<U> & {
        assertBetween(lower: BasicToFull<U>, upper: BasicToFull<U>): void;
    } : T[K] extends FlaggedOptionCondition<infer U> ? PreconditionSubclassType<U> : T[K] extends AsFieldElements<infer U> ? PreconditionSubclassType<U> : PreconditionClassType<T[K]>;
};
declare type BasicToFull<K> = K extends Types.UInt32 ? UInt32 : K extends Types.UInt64 ? UInt64 : K extends Field ? Field : K extends Bool ? Bool : K extends Types.PublicKey ? PublicKey : never;
declare type RangeCondition<T> = {
    lower: T;
    upper: T;
};
declare type FlaggedOptionCondition<T> = {
    isSome: Bool;
    value: T;
};
