import 'reflect-metadata';
import { Circuit, Bool } from '../snarky';
export { asFieldElementsToConstant, CircuitValue, prop, arrayProp, matrixProp, public_, circuitMain, cloneCircuitValue, circuitValueEquals, circuitArray, };
function asFieldElementsToConstant(typ, t) {
    const xs = typ.toFields(t);
    return typ.ofFields(xs);
}
// TODO: Synthesize the constructor if possible (bkase)
//
class CircuitValue {
    static sizeInFields() {
        const fields = this.prototype._fields;
        return fields.reduce((acc, [_, typ]) => acc + typ.sizeInFields(), 0);
    }
    static toFields(v) {
        const res = [];
        const fields = this.prototype._fields;
        if (fields === undefined || fields === null) {
            return res;
        }
        for (let i = 0, n = fields.length; i < n; ++i) {
            const [key, propType] = fields[i];
            const subElts = propType.toFields(v[key]);
            subElts.forEach((x) => res.push(x));
        }
        return res;
    }
    toFields() {
        return this.constructor.toFields(this);
    }
    toJSON() {
        return this.constructor.toJSON(this);
    }
    equals(x) {
        return Circuit.equal(this, x);
    }
    assertEquals(x) {
        Circuit.assertEqual(this, x);
    }
    static ofFields(xs) {
        const fields = this.prototype._fields;
        let offset = 0;
        const props = [];
        for (let i = 0; i < fields.length; ++i) {
            const propType = fields[i][1];
            const propSize = propType.sizeInFields();
            const propVal = propType.ofFields(xs.slice(offset, offset + propSize));
            props.push(propVal);
            offset += propSize;
        }
        return new this(...props);
    }
    static toConstant(t) {
        const xs = this.toFields(t);
        return this.ofFields(xs.map((x) => x.toConstant()));
    }
    static toJSON(v) {
        const res = {};
        if (this.prototype._fields !== undefined) {
            const fields = this.prototype._fields;
            fields.forEach(([key, propType]) => {
                res[key] = propType.toJSON(v[key]);
            });
        }
        return res;
    }
    static fromJSON(value) {
        const props = [];
        const fields = this.prototype._fields;
        switch (typeof value) {
            case 'object':
                if (value === null || Array.isArray(value)) {
                    return null;
                }
                break;
            default:
                return null;
        }
        if (fields !== undefined) {
            for (let i = 0; i < fields.length; ++i) {
                const [key, propType] = fields[i];
                if (value[key] === undefined) {
                    return null;
                }
                else {
                    props.push(propType.fromJSON(value[key]));
                }
            }
        }
        return new this(...props);
    }
}
CircuitValue.check = function (v) {
    const fields = this.prototype._fields;
    if (fields === undefined || fields === null) {
        return;
    }
    for (let i = 0; i < fields.length; ++i) {
        const [key, propType] = fields[i];
        const value = v[key];
        if (propType.check === undefined)
            throw Error('bug: circuit value without .check()');
        propType.check(value);
    }
};
function prop(target, key) {
    const fieldType = Reflect.getMetadata('design:type', target, key);
    if (!target.hasOwnProperty('_fields')) {
        target._fields = [];
    }
    if (fieldType === undefined) {
    }
    else if (fieldType.toFields && fieldType.ofFields) {
        target._fields.push([key, fieldType]);
    }
    else {
        console.log(`warning: property ${key} missing field element conversion methods`);
    }
}
function circuitArray(elementType, length) {
    return {
        sizeInFields() {
            let elementLength = elementType.sizeInFields();
            return elementLength * length;
        },
        toFields(array) {
            return array.map((e) => elementType.toFields(e)).flat();
        },
        ofFields(fields) {
            let array = [];
            let elementLength = elementType.sizeInFields();
            length = elementLength * length;
            for (let i = 0; i < length; i += elementLength) {
                array.push(elementType.ofFields(fields.slice(i, i + elementLength)));
            }
            return array;
        },
        check(array) {
            for (let i = 0; i < length; i++) {
                elementType.check(array[i]);
            }
        },
    };
}
function arrayProp(elementType, length) {
    return function (target, key) {
        if (!target.hasOwnProperty('_fields')) {
            target._fields = [];
        }
        target._fields.push([key, circuitArray(elementType, length)]);
    };
}
function matrixProp(elementType, nRows, nColumns) {
    return function (target, key) {
        if (!target.hasOwnProperty('_fields')) {
            target._fields = [];
        }
        target._fields.push([
            key,
            circuitArray(circuitArray(elementType, nColumns), nRows),
        ]);
    };
}
function public_(target, _key, index) {
    // const fieldType = Reflect.getMetadata('design:paramtypes', target, key);
    if (target._public === undefined) {
        target._public = [];
    }
    target._public.push(index);
}
function typeOfArray(typs) {
    return {
        sizeInFields: () => {
            return typs.reduce((acc, typ) => acc + typ.sizeInFields(), 0);
        },
        toFields: (t) => {
            if (t.length !== typs.length) {
                throw new Error(`typOfArray: Expected ${typs.length}, got ${t.length}`);
            }
            let res = [];
            for (let i = 0; i < t.length; ++i) {
                res.push(...typs[i].toFields(t[i]));
            }
            return res;
        },
        ofFields: (xs) => {
            let offset = 0;
            let res = [];
            typs.forEach((typ) => {
                const n = typ.sizeInFields();
                res.push(typ.ofFields(xs.slice(offset, offset + n)));
                offset += n;
            });
            return res;
        },
        check(xs) {
            typs.forEach((typ, i) => typ.check(xs[i]));
        },
    };
}
function circuitMain(target, propertyName, _descriptor) {
    const paramTypes = Reflect.getMetadata('design:paramtypes', target, propertyName);
    const numArgs = paramTypes.length;
    const publicIndexSet = new Set(target._public);
    const witnessIndexSet = new Set();
    for (let i = 0; i < numArgs; ++i) {
        if (!publicIndexSet.has(i)) {
            witnessIndexSet.add(i);
        }
    }
    target.snarkyMain = (w, pub) => {
        let args = [];
        for (let i = 0; i < numArgs; ++i) {
            args.push((publicIndexSet.has(i) ? pub : w).shift());
        }
        return target[propertyName].apply(target, args);
    };
    target.snarkyWitnessTyp = typeOfArray(Array.from(witnessIndexSet).map((i) => paramTypes[i]));
    target.snarkyPublicTyp = typeOfArray(Array.from(publicIndexSet).map((i) => paramTypes[i]));
}
let primitives = new Set(['Field', 'Bool', 'Scalar', 'Group']);
function cloneCircuitValue(obj) {
    // primitive JS types and functions aren't cloned
    if (typeof obj !== 'object' || obj === null)
        return obj;
    // built-in JS datatypes with custom cloning strategies
    if (Array.isArray(obj))
        return obj.map(cloneCircuitValue);
    if (obj instanceof Set)
        return new Set([...obj].map(cloneCircuitValue));
    if (obj instanceof Map)
        return new Map([...obj].map(([k, v]) => [k, cloneCircuitValue(v)]));
    if (ArrayBuffer.isView(obj))
        return new obj.constructor(obj);
    // snarkyjs primitives aren't cloned
    if (primitives.has(obj.constructor.name))
        return obj;
    // cloning strategy that works for plain objects AND classes whose constructor only assigns properties
    let propertyDescriptors = {};
    for (let [key, value] of Object.entries(obj)) {
        propertyDescriptors[key] = {
            value: cloneCircuitValue(value),
            writable: true,
            enumerable: true,
            configurable: true,
        };
    }
    return Object.create(Object.getPrototypeOf(obj), propertyDescriptors);
}
function circuitValueEquals(a, b) {
    // primitive JS types and functions are checked for exact equality
    if (typeof a !== 'object' || a === null)
        return a === b;
    // built-in JS datatypes with custom equality checks
    if (Array.isArray(a)) {
        return (Array.isArray(b) &&
            a.length === b.length &&
            a.every((a_, i) => circuitValueEquals(a_, b[i])));
    }
    if (a instanceof Set) {
        return (b instanceof Set && a.size === b.size && [...a].every((a_) => b.has(a_)));
    }
    if (a instanceof Map) {
        return (b instanceof Map &&
            a.size === b.size &&
            [...a].every(([k, v]) => circuitValueEquals(v, b.get(k))));
    }
    if (ArrayBuffer.isView(a) && !(a instanceof DataView)) {
        // typed array
        return (ArrayBuffer.isView(b) &&
            !(b instanceof DataView) &&
            circuitValueEquals([...a], [...b]));
    }
    // the two checks below cover snarkyjs primitives and CircuitValues
    // if we have an .equals method, try to use it
    if ('equals' in a && typeof a.equals === 'function') {
        let isEqual = a.equals(b).toBoolean();
        if (typeof isEqual === 'boolean')
            return isEqual;
        if (isEqual instanceof Bool)
            return isEqual.toBoolean();
    }
    // if we have a .toFields method, try to use it
    if ('toFields' in a &&
        typeof a.toFields === 'function' &&
        'toFields' in b &&
        typeof b.toFields === 'function') {
        let aFields = a.toFields();
        let bFields = b.toFields();
        return aFields.every((a, i) => a.equals(bFields[i]).toBoolean());
    }
    // equality test that works for plain objects AND classes whose constructor only assigns properties
    let aEntries = Object.entries(a).filter(([, v]) => v !== undefined);
    let bEntries = Object.entries(b).filter(([, v]) => v !== undefined);
    if (aEntries.length !== bEntries.length)
        return false;
    return aEntries.every(([key, value]) => key in b && circuitValueEquals(b[key], value));
}
