import { Bool, Field, Pickles, Circuit } from '../snarky';
import { getContext, withContext, withContextAsync } from './global-context';
// public API
export { Proof, SelfProof, ZkProgram };
// internal API
export { CompiledTag, sortMethodArguments, getPreviousProofsForProver, picklesRuleFromFunction, compileProgram, };
class Proof {
    constructor({ proof, publicInput }) {
        this.shouldVerify = Bool.false;
        this.publicInput = publicInput;
        this.proof = proof; // TODO optionally convert from string?
    }
    verify() {
        this.shouldVerify = Bool.true;
    }
    verifyIf(condition) {
        this.shouldVerify = condition;
    }
    toString() {
        return Pickles.proofToString(this.proof);
    }
}
Proof.publicInputType = undefined;
Proof.tag = () => {
    throw Error(`You cannot use the \`Proof\` class directly. Instead, define a subclass:\n` +
        `class MyProof extends Proof<PublicInput> { ... }`);
};
let compiledTags = new WeakMap();
let CompiledTag = {
    get(tag) {
        return compiledTags.get(tag);
    },
    store(tag, compiledTag) {
        compiledTags.set(tag, compiledTag);
    },
};
function ZkProgram({ publicInput: publicInputType, methods, }) {
    let selfTag = { name: `Program${i++}` };
    class SelfProof extends Proof {
    }
    SelfProof.publicInputType = publicInputType;
    SelfProof.tag = () => selfTag;
    let keys = Object.keys(methods).sort(); // need to have methods in (any) fixed order
    let methodIntfs = keys.map((key) => sortMethodArguments('program', key, methods[key].privateInput, SelfProof));
    let methodFunctions = keys.map((key) => methods[key].method);
    let compileOutput;
    async function compile() {
        let { provers, verify } = compileProgram(publicInputType, methodIntfs, methodFunctions, selfTag);
        compileOutput = { provers, verify };
    }
    function toProver(key, i) {
        async function prove(publicInput, ...args) {
            let picklesProver = compileOutput?.provers?.[i];
            if (picklesProver === undefined) {
                throw Error(`Cannot prove execution of program.${key}(), no prover found. ` +
                    `Try calling \`await program.compile()\` first, this will cache provers in the background.`);
            }
            let publicInputFields = publicInputType.toFields(publicInput);
            let previousProofs = getPreviousProofsForProver(args, methodIntfs[i]);
            let [, proof] = await withContextAsync({ witnesses: args, inProver: true }, () => picklesProver(publicInputFields, previousProofs));
            class ProgramProof extends Proof {
            }
            ProgramProof.publicInputType = publicInputType;
            ProgramProof.tag = () => selfTag;
            return new ProgramProof({ publicInput, proof });
        }
        return [key, prove];
    }
    let provers = Object.fromEntries(keys.map(toProver));
    return Object.assign(selfTag, { compile }, provers);
}
let i = 0;
class SelfProof extends Proof {
}
function sortMethodArguments(programName, methodName, privateInputs, selfProof) {
    let witnessArgs = [];
    let proofArgs = [];
    let allArgs = [];
    for (let i = 0; i < privateInputs.length; i++) {
        let privateInput = privateInputs[i];
        if (isProof(privateInput)) {
            if (privateInput === Proof) {
                throw Error(`You cannot use the \`Proof\` class directly. Instead, define a subclass:\n` +
                    `class MyProof extends Proof<PublicInput> { ... }`);
            }
            allArgs.push({ type: 'proof', index: proofArgs.length });
            if (privateInput === SelfProof) {
                proofArgs.push(selfProof);
            }
            else {
                proofArgs.push(privateInput);
            }
        }
        else if (isAsFields(privateInput)) {
            allArgs.push({ type: 'witness', index: witnessArgs.length });
            witnessArgs.push(privateInput);
        }
        else {
            throw Error(`Argument ${i + 1} of method ${methodName} is not a valid circuit value: ${privateInput}`);
        }
    }
    if (proofArgs.length > 2) {
        throw Error(`${programName}.${methodName}() has more than two proof arguments, which is not supported.\n` +
            `Suggestion: You can merge more than two proofs by merging two at a time in a binary tree.`);
    }
    return { methodName, witnessArgs, proofArgs, allArgs };
}
function isAsFields(type) {
    return (typeof type === 'function' &&
        ['toFields', 'ofFields', 'sizeInFields'].every((s) => s in type));
}
function isProof(type) {
    // the second case covers subclasses
    return (type === Proof ||
        (typeof type === 'function' && type.prototype instanceof Proof));
}
function getPreviousProofsForProver(methodArgs, { allArgs, proofArgs }) {
    let previousProofs = [];
    for (let i = 0; i < allArgs.length; i++) {
        let arg = allArgs[i];
        if (arg.type === 'proof') {
            let { proof, publicInput } = methodArgs[i];
            let publicInputType = getPublicInputType(proofArgs[arg.index]);
            previousProofs[arg.index] = {
                publicInput: publicInputType.toFields(publicInput),
                proof,
            };
        }
    }
    return previousProofs;
}
function compileProgram(publicInputType, methodIntfs, methods, proofSystemTag, additionalContext) {
    let rules = methodIntfs.map((methodEntry, i) => picklesRuleFromFunction(publicInputType, methods[i], proofSystemTag, methodEntry));
    let [, { getVerificationKeyArtifact, provers, verify, tag }] = withContext({ inCompile: true, ...additionalContext }, () => Pickles.compile(rules, publicInputType.sizeInFields()));
    CompiledTag.store(proofSystemTag, tag);
    return { getVerificationKeyArtifact, provers, verify, tag };
}
function picklesRuleFromFunction(publicInputType, func, proofSystemTag, { methodName, witnessArgs, proofArgs, allArgs }) {
    function main(publicInput, previousInputs) {
        let { witnesses: argsWithoutPublicInput } = getContext();
        let finalArgs = [];
        let proofs = [];
        for (let i = 0; i < allArgs.length; i++) {
            let arg = allArgs[i];
            if (arg.type === 'witness') {
                let type = witnessArgs[arg.index];
                finalArgs[i] = argsWithoutPublicInput
                    ? Circuit.witness(type, () => argsWithoutPublicInput[i])
                    : emptyWitness(type);
            }
            else {
                let Proof = proofArgs[arg.index];
                let publicInput = getPublicInputType(Proof).ofFields(previousInputs[arg.index]);
                let proofInstance;
                if (argsWithoutPublicInput) {
                    let { proof } = argsWithoutPublicInput[i];
                    proofInstance = new Proof({ publicInput, proof });
                }
                else {
                    proofInstance = new Proof({ publicInput, proof: undefined });
                }
                finalArgs[i] = proofInstance;
                proofs.push(proofInstance);
            }
        }
        func(publicInputType.ofFields(publicInput), ...finalArgs);
        return proofs.map((proof) => proof.shouldVerify);
    }
    if (proofArgs.length > 2) {
        throw Error(`${proofSystemTag.name}.${methodName}() has more than two proof arguments, which is not supported.\n` +
            `Suggestion: You can merge more than two proofs by merging two at a time in a binary tree.`);
    }
    let proofsToVerify = proofArgs.map((Proof) => {
        let tag = Proof.tag();
        if (tag === proofSystemTag)
            return { isSelf: true };
        else {
            let compiledTag = CompiledTag.get(tag);
            if (compiledTag === undefined) {
                throw Error(`${proofSystemTag.name}.compile() depends on ${tag.name}, but we cannot find compilation output for ${tag.name}.\n` +
                    `Try to run ${tag.name}.compile() first.`);
            }
            return { isSelf: false, tag: compiledTag };
        }
    });
    return { identifier: methodName, main, proofsToVerify };
}
function emptyWitness(typ) {
    // return typ.ofFields(Array(typ.sizeInFields()).fill(Field.zero));
    return Circuit.witness(typ, () => typ.ofFields(Array(typ.sizeInFields()).fill(Field.zero)));
}
function getPublicInputType(Proof) {
    if (Proof.publicInputType === undefined) {
        throw Error(`You cannot use the \`Proof\` class directly. Instead, define a subclass:\n` +
            `class MyProof extends Proof<PublicInput> { ... }`);
    }
    return Proof.publicInputType;
}
