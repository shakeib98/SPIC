import { Field, Types } from '../snarky';
import { CircuitValue } from './circuit_value';
export { UInt32, UInt64, Int64 };
declare class UInt64 extends CircuitValue implements Types.UInt64 {
    value: Field;
    static NUM_BITS: number;
    _type?: 'UInt64';
    constructor(value: Field);
    static get zero(): UInt64;
    static get one(): UInt64;
    toString(): string;
    static check(x: Types.UInt64): void;
    private static checkConstant;
    static from(x: UInt64 | UInt32 | Field | number | string | bigint): UInt64;
    static fromNumber(x: number): UInt64;
    static fromString(x: string): UInt64;
    static fromBigInt(x: bigint): UInt64;
    static MAXINT(): UInt64;
    divMod(y: UInt64 | number | string): {
        quotient: UInt64;
        rest: UInt64;
    };
    /**
     * Integer division.
     *
     * `x.div(y)` returns the floor of `x / y`, that is, the greatest
     * `z` such that `x * y <= x`.
     *
     */
    div(y: UInt64 | number): UInt64;
    /**
     * Integer remainder.
     *
     * `x.mod(y)` returns the value `z` such that `0 <= z < y` and
     * `x - z` is divisble by `y`.
     */
    mod(y: UInt64 | number): UInt64;
    /**
     * Multiplication with overflow checking.
     */
    mul(y: UInt64 | number): UInt64;
    /**
     * Addition with overflow checking.
     */
    add(y: UInt64 | number): UInt64;
    /**
     * Subtraction with underflow checking.
     */
    sub(y: UInt64 | number): UInt64;
    lte(y: UInt64): Types.Bool;
    assertLte(y: UInt64): void;
    lt(y: UInt64): Types.Bool;
    assertLt(y: UInt64): void;
    gt(y: UInt64): Types.Bool;
    assertGt(y: UInt64): void;
}
declare class UInt32 extends CircuitValue implements Types.UInt32 {
    value: Field;
    static NUM_BITS: number;
    _type?: 'UInt32';
    constructor(value: Field);
    static get zero(): UInt32;
    static get one(): UInt32;
    toString(): string;
    toUInt64(): UInt64;
    static check(x: Types.UInt32): void;
    private static checkConstant;
    static from(x: UInt32 | Field | number | string | bigint): UInt32;
    static fromNumber(x: number): UInt32;
    static fromString(x: string): UInt32;
    static fromBigInt(x: bigint): UInt32;
    static MAXINT(): UInt32;
    divMod(y: UInt32 | number | string): {
        quotient: UInt32;
        rest: UInt32;
    };
    div(y: UInt32 | number): UInt32;
    mod(y: UInt32 | number): UInt32;
    mul(y: UInt32 | number): UInt32;
    add(y: UInt32 | number): UInt32;
    sub(y: UInt32 | number): UInt32;
    lte(y: UInt32): Types.Bool;
    assertLte(y: UInt32): void;
    lt(y: UInt32): Types.Bool;
    assertLt(y: UInt32): void;
    gt(y: UInt32): Types.Bool;
    assertGt(y: UInt32): void;
}
declare type BalanceChange = Types.Party['body']['balanceChange'];
declare class Int64 extends CircuitValue implements BalanceChange {
    magnitude: UInt64;
    sgn: Field;
    constructor(magnitude: UInt64, sgn?: Field);
    private static fromFieldUnchecked;
    static fromUnsigned(x: UInt64 | UInt32): Int64;
    static from(x: Int64 | UInt32 | UInt64 | Field | number | string | bigint): Int64;
    static fromNumber(x: number): Int64;
    static fromString(x: string): Int64;
    static fromBigInt(x: bigint): Int64;
    toString(): string;
    isConstant(): boolean;
    static check(x: Int64): void;
    static get zero(): Int64;
    static get one(): Int64;
    static get minusOne(): Int64;
    toField(): Field;
    static fromField(x: Field): Int64;
    neg(): Int64;
    add(y: Int64 | number | string | bigint | UInt64 | UInt32): Int64;
    sub(y: Int64 | number | string | bigint | UInt64 | UInt32): Int64;
    mul(y: Int64 | number | string | bigint | UInt64 | UInt32): Int64;
    div(y: Int64 | number | string | bigint | UInt64 | UInt32): Int64;
    mod(y: UInt64 | number | string | bigint | UInt32): Int64;
    equals(y: Int64 | number | string | bigint | UInt64 | UInt32): Types.Bool;
    assertEquals(y: Int64 | number | string | bigint | UInt64 | UInt32): void;
    isPositive(): Types.Bool;
}
