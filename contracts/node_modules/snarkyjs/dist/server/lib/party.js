import { cloneCircuitValue } from './circuit_value';
import { Field, Bool, Ledger, Circuit, Pickles, Types } from '../snarky';
import { PrivateKey, PublicKey } from './signature';
import { UInt64, UInt32, Int64 } from './int';
import * as Mina from './mina';
import { withContextAsync } from './global-context';
import * as Precondition from './precondition';
export { Permission, Permissions, Preconditions, Body, Party, toPartyUnsafe, toPartiesUnsafe, partiesToJson, addMissingSignatures, addMissingProofs, signJsonTransaction, ZkappStateLength, };
const ZkappStateLength = 8;
function keep(dummy) {
    return { isSome: Bool(false), value: dummy };
}
const True = () => Bool(true);
const False = () => Bool(false);
let Permission = {
    /**
     * Modification is impossible.
     */
    impossible: () => ({
        constant: True(),
        signatureNecessary: True(),
        signatureSufficient: False(),
    }),
    /**
     * Modification is always permitted
     */
    none: () => ({
        constant: True(),
        signatureNecessary: False(),
        signatureSufficient: True(),
    }),
    /**
     * Modification is permitted by zkapp proofs only
     */
    proof: () => ({
        constant: False(),
        signatureNecessary: False(),
        signatureSufficient: False(),
    }),
    /**
     * Modification is permitted by signatures only, using the private key of the zkapp account
     */
    signature: () => ({
        constant: False(),
        signatureNecessary: True(),
        signatureSufficient: True(),
    }),
    /**
     * Modification is permitted by zkapp proofs or signatures
     */
    proofOrSignature: () => ({
        constant: False(),
        signatureNecessary: False(),
        signatureSufficient: True(),
    }),
};
let Permissions = {
    ...Permission,
    /**
     * Default permissions are:
     *   [[ Permissions.editState ]]=[[ Permission.proof ]]
     *   [[ Permissions.send ]]=[[ Permission.signature ]]
     *   [[ Permissions.receive ]]=[[ Permission.proof ]]
     *   [[ Permissions.setDelegate ]]=[[ Permission.signature ]]
     *   [[ Permissions.setPermissions ]]=[[ Permission.signature ]]
     *   [[ Permissions.setVerificationKey ]]=[[ Permission.signature ]]
     *   [[ Permissions.setZkappUri ]]=[[ Permission.signature ]]
     *   [[ Permissions.editSequenceState ]]=[[ Permission.proof ]]
     *   [[ Permissions.setTokenSymbol ]]=[[ Permission.signature ]]
     */
    default: () => ({
        editState: Permission.proof(),
        send: Permission.signature(),
        receive: Permission.proof(),
        setDelegate: Permission.signature(),
        setPermissions: Permission.signature(),
        setVerificationKey: Permission.signature(),
        setZkappUri: Permission.signature(),
        editSequenceState: Permission.proof(),
        setTokenSymbol: Permission.signature(),
        incrementNonce: Permissions.signature(),
        setVotingFor: Permission.signature(),
    }),
    initial: () => ({
        editState: Permission.signature(),
        send: Permission.signature(),
        receive: Permission.none(),
        setDelegate: Permission.signature(),
        setPermissions: Permission.signature(),
        setVerificationKey: Permission.signature(),
        setZkappUri: Permission.signature(),
        editSequenceState: Permission.signature(),
        setTokenSymbol: Permission.signature(),
        incrementNonce: Permissions.signature(),
        setVotingFor: Permission.signature(),
    }),
};
const getDefaultTokenId = () => Field.one;
// TODO
class Events {
    constructor(hash, events) {
        this.hash = hash;
        this.data = events;
    }
    // TODO don't hard-code, implement hashes
    static empty() {
        let emptyHash = Field('23641812384071365026036270005604392899711718400522999453895455265440046333209');
        return new Events(emptyHash, []);
    }
    static emptySequenceState() {
        return Field('19777675955122618431670853529822242067051263606115426372178827525373304476695');
    }
}
const Body = {
    noUpdate() {
        return {
            appState: Array(ZkappStateLength)
                .fill(0)
                .map(() => keep(Field.zero)),
            delegate: keep(PublicKey.empty()),
            // TODO
            verificationKey: keep({ data: '', hash: Field.zero }),
            permissions: keep(Permissions.initial()),
            // TODO don't hard code
            zkappUri: keep({
                data: '',
                hash: Field('22930868938364086394602058221028773520482901241511717002947639863679740444066'),
            }),
            // TODO
            tokenSymbol: keep({ data: '', hash: Field.zero }),
            timing: keep({
                cliffAmount: UInt64.zero,
                cliffTime: UInt32.zero,
                initialMinimumBalance: UInt64.zero,
                vestingIncrement: UInt64.zero,
                vestingPeriod: UInt32.zero,
            }),
            votingFor: keep(Field.zero),
        };
    },
    /**
     * A body that Don't change part of the underlying account record.
     */
    keepAll(publicKey) {
        return {
            publicKey,
            update: Body.noUpdate(),
            tokenId: getDefaultTokenId(),
            balanceChange: Int64.zero,
            events: Events.empty(),
            sequenceEvents: Events.empty(),
            caller: getDefaultTokenId(),
            callData: Field.zero,
            callDepth: 0,
            preconditions: Preconditions.ignoreAll(),
            // the default assumption is that snarkyjs transactions don't include the fee payer
            // so useFullCommitment has to be false for signatures to be correct
            useFullCommitment: Bool(false),
            // this should be set to true if parties are signed
            incrementNonce: Bool(false),
        };
    },
    dummy() {
        return Body.keepAll(PublicKey.empty());
    },
};
const FeePayerBody = {
    keepAll(publicKey, nonce) {
        return {
            publicKey,
            nonce,
            fee: UInt64.zero,
            update: Body.noUpdate(),
            events: Events.empty(),
            sequenceEvents: Events.empty(),
            networkPrecondition: NetworkPrecondition.ignoreAll(),
        };
    },
};
let NetworkPrecondition = {
    ignoreAll() {
        let stakingEpochData = {
            ledger: { hash: ignore(Field.zero), totalCurrency: uint64() },
            seed: ignore(Field.zero),
            startCheckpoint: ignore(Field.zero),
            lockCheckpoint: ignore(Field.zero),
            epochLength: uint32(),
        };
        let nextEpochData = cloneCircuitValue(stakingEpochData);
        return {
            snarkedLedgerHash: ignore(Field.zero),
            timestamp: uint64(),
            blockchainLength: uint32(),
            minWindowDensity: uint32(),
            totalCurrency: uint64(),
            globalSlotSinceHardFork: uint32(),
            globalSlotSinceGenesis: uint32(),
            stakingEpochData,
            nextEpochData,
        };
    },
};
/**
 * Ignores a `dummy`
 *
 * @param dummy The value to ignore
 * @returns Always an ignored value regardless of the input.
 */
function ignore(dummy) {
    return { isSome: Bool(false), value: dummy };
}
/**
 * Ranges between all uint32 values
 */
const uint32 = () => ({ lower: UInt32.fromNumber(0), upper: UInt32.MAXINT() });
/**
 * Ranges between all uint64 values
 */
const uint64 = () => ({ lower: UInt64.fromNumber(0), upper: UInt64.MAXINT() });
const AccountPrecondition = {
    ignoreAll() {
        let appState = [];
        for (let i = 0; i < ZkappStateLength; ++i) {
            appState.push(ignore(Field.zero));
        }
        return {
            balance: uint64(),
            nonce: uint32(),
            receiptChainHash: ignore(Field.zero),
            delegate: ignore(PublicKey.empty()),
            state: appState,
            sequenceState: Events.emptySequenceState(),
            provedState: ignore(Bool(false)),
        };
    },
    nonce(nonce) {
        let p = AccountPrecondition.ignoreAll();
        Party.assertEquals(p.nonce, nonce);
        return p;
    },
};
const Preconditions = {
    ignoreAll() {
        return {
            account: AccountPrecondition.ignoreAll(),
            network: NetworkPrecondition.ignoreAll(),
        };
    },
};
class Party {
    constructor(body, authorization = {}, isSelf = false) {
        this.body = body;
        this.authorization = authorization;
        let { account, network } = Precondition.preconditions(this, isSelf);
        this.account = account;
        this.network = network;
        this.isSelf = isSelf;
    }
    static clone(party) {
        let body = cloneCircuitValue(party.body);
        let authorization = cloneCircuitValue(party.authorization);
        return new Party(body, authorization, party.isSelf);
    }
    get balance() {
        let party = this;
        return {
            addInPlace(x) {
                party.body.balanceChange = party.body.balanceChange.add(x);
            },
            subInPlace(x) {
                party.body.balanceChange = party.body.balanceChange.sub(x);
            },
        };
    }
    get update() {
        return this.body.update;
    }
    static setValue(maybeValue, value) {
        maybeValue.isSome = Bool(true);
        maybeValue.value = value;
    }
    /** Constrain a property to lie between lower and upper bounds.
     *
     * @param property The property to constrain
     * @param lower The lower bound
     * @param upper The upper bound
     *
     * Example: To constrain the account balance of a SmartContract to lie between 0 and 20 MINA, you can use
     *
     * ```ts
     * @method onlyRunsWhenBalanceIsLow() {
     *   let lower = UInt64.zero;
     *   let upper = UInt64.fromNumber(20e9);
     *   Party.assertBetween(this.self.body.accountPrecondition.balance, lower, upper);
     *   // ...
     * }
     * ```
     */
    static assertBetween(property, lower, upper) {
        property.lower = lower;
        property.upper = upper;
    }
    // TODO: assertGreaterThan, assertLowerThan?
    /** Fix a property to a certain value.
     *
     * @param property The property to constrain
     * @param value The value it is fixed to
     *
     * Example: To fix the account nonce of a SmartContract to 0, you can use
     *
     * ```ts
     * @method onlyRunsWhenNonceIsZero() {
     *   Party.assertEquals(this.self.body.accountPrecondition.nonce, UInt32.zero);
     *   // ...
     * }
     * ```
     */
    static assertEquals(property, value) {
        if ('isSome' in property) {
            property.isSome = Bool(true);
            property.value = value;
        }
        else if ('lower' in property) {
            property.lower = value;
            property.upper = value;
        }
        else {
            throw Error('assertEquals: Invalid argument');
        }
    }
    get publicKey() {
        return this.body.publicKey;
    }
    signInPlace(privateKey, fallbackToZeroNonce = false) {
        this.setNoncePrecondition(fallbackToZeroNonce);
        this.body.incrementNonce = Bool(true);
        this.authorization = { kind: 'lazy-signature', privateKey };
    }
    sign(privateKey) {
        let party = Party.clone(this);
        party.signInPlace(privateKey);
        return party;
    }
    static signFeePayerInPlace(feePayer, privateKey, fallbackToZeroNonce = false) {
        feePayer.body.nonce = this.getNonce(feePayer, fallbackToZeroNonce);
        feePayer.authorization = { kind: 'lazy-signature', privateKey };
    }
    // TODO this needs to be more intelligent about previous nonces in the transaction, similar to Party.createSigned
    static getNonce(party, fallbackToZero = false) {
        let nonce;
        try {
            let inProver = Circuit.inProver();
            if (inProver || !Circuit.inCheckedComputation()) {
                let account = Mina.getAccount(party.body.publicKey);
                nonce = inProver
                    ? Circuit.witness(UInt32, () => account.nonce)
                    : account.nonce;
            }
            else {
                nonce = Circuit.witness(UInt32, () => {
                    throw Error('this should never happen');
                });
            }
        }
        catch (err) {
            if (fallbackToZero)
                nonce = UInt32.zero;
            else
                throw err;
        }
        return nonce;
    }
    setNoncePrecondition(fallbackToZero = false) {
        let nonce = Party.getNonce(this, fallbackToZero);
        let accountPrecondition = this.body.preconditions.account;
        Party.assertEquals(accountPrecondition.nonce, nonce);
        return nonce;
    }
    toFields() {
        return Types.Party.toFields(toPartyUnsafe(this));
    }
    hash() {
        let fields = Types.Party.toFields(toPartyUnsafe(this));
        return Ledger.hashPartyFromFields(fields);
    }
    static defaultParty(address) {
        const body = Body.keepAll(address);
        return new Party(body);
    }
    static defaultFeePayer(address, key, nonce) {
        let body = FeePayerBody.keepAll(address, nonce);
        return { body, authorization: { kind: 'lazy-signature', privateKey: key } };
    }
    static dummyFeePayer() {
        let body = FeePayerBody.keepAll(PublicKey.empty(), UInt32.zero);
        return { body, authorization: undefined };
    }
    static createUnsigned(publicKey) {
        // TODO: This should be a witness block that uses the setVariable
        // API to set the value of a variable after it's allocated
        const pk = publicKey;
        const body = Body.keepAll(pk);
        if (Mina.currentTransaction === undefined) {
            throw new Error('Party.createUnsigned: Cannot run outside of a transaction');
        }
        const party = new Party(body);
        Mina.currentTransaction.nextPartyIndex++;
        Mina.currentTransaction.parties.push(party);
        return party;
    }
    static createSigned(signer, options) {
        let { nonce, isSameAsFeePayer } = options ?? {};
        // if not specified, optimistically determine isSameAsFeePayer from the current transaction
        // (gotcha: this makes the circuit depend on the fee payer parameter in the transaction.
        // to avoid that, provide the argument explicitly)
        let isFeePayer = isSameAsFeePayer !== undefined
            ? Bool(isSameAsFeePayer)
            : Mina.currentTransaction?.sender?.equals(signer) ?? Bool(false);
        // TODO: This should be a witness block that uses the setVariable
        // API to set the value of a variable after it's allocated
        let publicKey = signer.toPublicKey();
        let body = Body.keepAll(publicKey);
        // TODO: getAccount could always be used if we had a generic way to add account info prior to creating transactions
        if (nonce === undefined) {
            let account = Mina.getAccount(publicKey);
            nonce = account.nonce;
        }
        if (Mina.currentTransaction === undefined) {
            throw new Error('Party.createSigned: Cannot run outside of a transaction');
        }
        // if the fee payer is the same party as this one, we have to start the nonce predicate at one higher bc the fee payer already increases its nonce
        let nonceIncrement = Circuit.if(isFeePayer, new UInt32(Field.one), UInt32.zero);
        // now, we check how often this party already updated its nonce in this tx, and increase nonce from `getAccount` by that amount
        for (let party of Mina.currentTransaction.parties) {
            let shouldIncreaseNonce = party.publicKey
                .equals(publicKey)
                .and(party.body.incrementNonce);
            nonceIncrement.add(new UInt32(shouldIncreaseNonce.toField()));
        }
        nonce = nonce.add(nonceIncrement);
        Party.assertEquals(body.preconditions.account.nonce, nonce);
        body.incrementNonce = Bool(true);
        let party = new Party(body);
        party.authorization = { kind: 'lazy-signature', privateKey: signer };
        Mina.currentTransaction.nextPartyIndex++;
        Mina.currentTransaction.parties.push(party);
        return party;
    }
    /**
     * Use this method to pay the account creation fee for another account.
     * Beware that you _don't_ need to pass in the new account!
     * Instead, the protocol will automatically identify accounts in your transaction that need funding.
     *
     * If you provide an optional `initialBalance`, this will be subtracted from the fee-paying account as well,
     * but you have to separately ensure that it's added to the new account's balance.
     *
     * @param feePayerKey the private key of the account that pays the fee
     * @param initialBalance the initial balance of the new account (default: 0)
     */
    static fundNewAccount(feePayerKey, { initialBalance = UInt64.zero, isSameAsFeePayer = undefined, } = {}) {
        let party = Party.createSigned(feePayerKey, { isSameAsFeePayer });
        let amount = initialBalance instanceof UInt64
            ? initialBalance
            : UInt64.fromString(`${initialBalance}`);
        party.balance.subInPlace(amount.add(Mina.accountCreationFee()));
    }
}
// TODO: probably shouldn't hard-code dummy signature
const dummySignature = '7mWxjLYgbJUkZNcGouvhVj5tJ8yu9hoexb9ntvPK8t5LHqzmrL6QJjjKtf5SgmxB4QWkDw7qoMMbbNGtHVpsbJHPyTy2EzRQ';
// TODO find a better name for these to make it clearer what they do (replace any lazy authorization with no/dummy authorization)
function toFeePayerUnsafe(feePayer) {
    let { body, authorization } = feePayer;
    if (typeof authorization === 'string')
        return { body, authorization };
    else {
        return { body, authorization: dummySignature };
    }
}
function toPartyUnsafe({ body, authorization }) {
    return {
        body,
        authorization: 'kind' in authorization ? {} : authorization,
    };
}
function toPartiesUnsafe({ feePayer, otherParties, memo, }) {
    return {
        feePayer: toFeePayerUnsafe(feePayer),
        otherParties: otherParties.map(toPartyUnsafe),
        memo: Ledger.memoToBase58(memo),
    };
}
function partiesToJson(parties) {
    return Types.Parties.toJson(toPartiesUnsafe(parties));
}
function addMissingSignatures(parties, additionalKeys = []) {
    let additionalPublicKeys = additionalKeys.map((sk) => sk.toPublicKey());
    let { commitment, fullCommitment } = Ledger.transactionCommitments(JSON.stringify(partiesToJson(parties)));
    function addFeePayerSignature(party) {
        let { body, authorization } = cloneCircuitValue(party);
        if (typeof authorization === 'string')
            return { body, authorization };
        if (authorization === undefined)
            return { body, authorization: dummySignature };
        let { privateKey } = authorization;
        if (privateKey === undefined) {
            let i = additionalPublicKeys.findIndex((pk) => pk === party.body.publicKey);
            if (i === -1) {
                let pk = PublicKey.toBase58(party.body.publicKey);
                throw Error(`addMissingSignatures: Cannot add signature for fee payer (${pk}), private key is missing.`);
            }
            privateKey = additionalKeys[i];
        }
        let signature = Ledger.signFieldElement(fullCommitment, privateKey);
        return { body, authorization: signature };
    }
    function addSignature(party) {
        party = Party.clone(party);
        if (!('kind' in party.authorization) ||
            party.authorization.kind !== 'lazy-signature')
            return party;
        let { privateKey } = party.authorization;
        if (privateKey === undefined) {
            let i = additionalPublicKeys.findIndex((pk) => pk.equals(party.body.publicKey));
            if (i === -1)
                throw Error(`addMissingSignatures: Cannot add signature for ${party.publicKey.toBase58()}, private key is missing.`);
            privateKey = additionalKeys[i];
        }
        let transactionCommitment = party.body.useFullCommitment.toBoolean()
            ? fullCommitment
            : commitment;
        let signature = Ledger.signFieldElement(transactionCommitment, privateKey);
        party.authorization = { signature };
        return party;
    }
    let { feePayer, otherParties, memo } = parties;
    return {
        feePayer: addFeePayerSignature(feePayer),
        otherParties: otherParties.map((p) => addSignature(p)),
        memo,
    };
}
async function addMissingProofs(parties) {
    let partiesJson = JSON.stringify(partiesToJson(parties));
    async function addProof(party, index) {
        party = Party.clone(party);
        if (!('kind' in party.authorization) ||
            party.authorization.kind !== 'lazy-proof')
            return party;
        let { method, args, ZkappClass } = party.authorization;
        let statement = Ledger.zkappPublicInput(partiesJson, index);
        if (ZkappClass._provers === undefined)
            throw Error(`Cannot prove execution of ${method.name}(), no prover found. ` +
                `Try calling \`await ${ZkappClass.name}.compile()\` first, this will cache provers in the background.`);
        let provers = ZkappClass._provers;
        let methodError = `Error when computing proofs: Method ${method.name} not found. ` +
            `Make sure your environment supports decorators, and annotate with \`@method ${method.name}\`.`;
        if (ZkappClass._methods === undefined)
            throw Error(methodError);
        let i = ZkappClass._methods.findIndex((m) => m.methodName === method.name);
        if (i === -1)
            throw Error(methodError);
        let [, proof] = await withContextAsync({
            self: Party.defaultParty(party.body.publicKey),
            witnesses: args,
            inProver: true,
        }, () => provers[i](statement, []));
        party.authorization = { proof: Pickles.proofToString(proof) };
        return party;
    }
    let { feePayer, otherParties, memo } = parties;
    // compute proofs serially. in parallel would clash with our global variable hacks
    let otherPartiesProved = [];
    for (let i = 0; i < otherParties.length; i++) {
        let partyProved = await addProof(otherParties[i], i);
        otherPartiesProved.push(partyProved);
    }
    return { feePayer, otherParties: otherPartiesProved, memo };
}
/**
 * Sign all parties of a transaction which belong to the account determined by [[ `privateKey` ]].
 * @returns the modified transaction JSON
 */
function signJsonTransaction(transactionJson, privateKey) {
    if (typeof privateKey === 'string')
        privateKey = PrivateKey.fromBase58(privateKey);
    let publicKey = privateKey.toPublicKey().toBase58();
    // TODO: we really need types for the parties json
    let parties = JSON.parse(transactionJson);
    let feePayer = parties.feePayer;
    if (feePayer.body.publicKey === publicKey) {
        parties = JSON.parse(Ledger.signFeePayer(JSON.stringify(parties), privateKey));
    }
    for (let i = 0; i < parties.otherParties.length; i++) {
        let party = parties.otherParties[i];
        if (party.body.publicKey === publicKey &&
            party.authorization.proof === null) {
            parties = JSON.parse(Ledger.signOtherParty(JSON.stringify(parties), privateKey, i));
        }
    }
    return JSON.stringify(parties);
}
