import { Field, Types } from '../snarky';
import { UInt32, UInt64 } from './int';
import { PrivateKey } from './signature';
import { Parties, Party } from './party';
import * as Fetch from './fetch';
import { NetworkValue } from './precondition';
export { createUnsignedTransaction, createTransaction, BerkeleyQANet, LocalBlockchain, nextTransactionId, CurrentTransaction, setCurrentTransaction, setActiveInstance, transaction, currentSlot, getAccount, getBalance, getNetworkState, accountCreationFee, sendTransaction, };
interface TransactionId {
    wait(): Promise<void>;
}
interface Transaction {
    transaction: Parties;
    toJSON(): string;
    toGraphqlQuery(): string;
    sign(additionialKeys?: PrivateKey[]): Transaction;
    prove(): Promise<Transaction>;
    send(): TransactionId;
}
declare type Account = Fetch.Account;
declare let nextTransactionId: {
    value: number;
};
declare type FetchMode = 'fetch' | 'cached' | 'test';
declare type CurrentTransaction = undefined | {
    sender?: PrivateKey;
    parties: Party[];
    nextPartyIndex: number;
    fetchMode: FetchMode;
};
export declare let currentTransaction: CurrentTransaction;
declare function setCurrentTransaction(transaction: CurrentTransaction): void;
declare type SenderSpec = PrivateKey | {
    feePayerKey: PrivateKey;
    fee?: number | string | UInt64;
    memo?: string;
} | undefined;
declare function createUnsignedTransaction(f: () => unknown, { fetchMode }?: {
    fetchMode?: FetchMode | undefined;
}): Transaction;
declare function createTransaction(feePayer: SenderSpec, f: () => unknown, { fetchMode }?: {
    fetchMode?: FetchMode | undefined;
}): Transaction;
interface Mina {
    transaction(sender: SenderSpec, f: () => void): Promise<Transaction>;
    currentSlot(): UInt32;
    getAccount(publicKey: Types.PublicKey): Account;
    getNetworkState(): NetworkValue;
    accountCreationFee(): UInt64;
    sendTransaction(transaction: Transaction): TransactionId;
}
interface MockMina extends Mina {
    addAccount(publicKey: Types.PublicKey, balance: string): void;
    /**
     * An array of 10 test accounts that have been pre-filled with
     * 30000000000 units of currency.
     */
    testAccounts: Array<{
        publicKey: Types.PublicKey;
        privateKey: PrivateKey;
    }>;
    applyJsonTransaction: (tx: string) => void;
}
/**
 * A mock Mina blockchain running locally and useful for testing.
 */
declare function LocalBlockchain({ accountCreationFee, }?: {
    accountCreationFee?: string | number | undefined;
}): MockMina;
declare function BerkeleyQANet(graphqlEndpoint: string): Mina;
/**
 * Set the currently used Mina instance.
 */
declare function setActiveInstance(m: Mina): void;
/**
 * Construct a smart contract transaction. Within the callback passed to this function,
 * you can call into the methods of smart contracts.
 *
 * ```typescript
 * transaction(() => {
 *   myZkapp.update();
 *   someOtherZkapp.someOtherMethod();
 * })
 * ```
 *
 * @return A transaction that can subsequently be submitted to the chain.
 */
declare function transaction(f: () => void): Promise<Transaction>;
declare function transaction(sender: SenderSpec, f: () => void): Promise<Transaction>;
/**
 * @return The current slot number, according to the active Mina instance.
 */
declare function currentSlot(): UInt32;
/**
 * @return The account data associated to the given public key.
 */
declare function getAccount(pubkey: Types.PublicKey): Fetch.Account;
/**
 * @return Data associated with the current state of the Mina network.
 */
declare function getNetworkState(): {
    snarkedLedgerHash: Field;
    timestamp: UInt64;
    blockchainLength: UInt32;
    minWindowDensity: UInt32;
    totalCurrency: UInt64;
    globalSlotSinceHardFork: UInt32;
    globalSlotSinceGenesis: UInt32;
    stakingEpochData: {
        ledger: {
            hash: Field;
            totalCurrency: UInt64;
        };
        seed: Field;
        startCheckpoint: Field;
        lockCheckpoint: Field;
        epochLength: UInt32;
    };
    nextEpochData: {
        ledger: {
            hash: Field;
            totalCurrency: UInt64;
        };
        seed: Field;
        startCheckpoint: Field;
        lockCheckpoint: Field;
        epochLength: UInt32;
    };
};
/**
 * @return The balance associated to the given public key.
 */
declare function getBalance(pubkey: Types.PublicKey): UInt64;
declare function accountCreationFee(): UInt64;
declare function sendTransaction(txn: Transaction): TransactionId;
