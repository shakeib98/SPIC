import { Field, Bool, Ledger } from '../snarky';
export { Field, Bool };
export { convertEventsToJson, convertEventsToFields, convertStringWithHashToJson, convertStringWithHashToFields, };
export { toJson, toJsonLeafTypes, toFields, toFieldsLeafTypes };
// json conversion
function identity(x) {
    return x;
}
function asString(x) {
    return x.toString();
}
let ToJson = {
    PublicKey(x) {
        return Ledger.publicKeyToString(x);
    },
    Field: asString,
    Bool(x) {
        return x.toBoolean();
    },
    AuthRequired(x) {
        let c = Number(x.constant.toBoolean());
        let n = Number(x.signatureNecessary.toBoolean());
        let s = Number(x.signatureSufficient.toBoolean());
        // prettier-ignore
        switch (`${c}${n}${s}`) {
            case '110': return 'Impossible';
            case '101': return 'None';
            case '000': return 'Proof';
            case '011': return 'Signature';
            case '001': return 'Either';
            default: throw Error('Unexpected permission');
        }
    },
    UInt32: asString,
    UInt64: asString,
    TokenId(x) {
        return Ledger.fieldToBase58(x);
    },
    Sign(x) {
        if (x.toString() === '1')
            return 'Positive';
        if (x.neg().toString() === '1')
            return 'Negative';
        throw Error(`Invalid Sign: ${x}`);
    },
    // TODO this is a hack
    BlockTimeInterval(_) {
        return null;
    },
    // builtin
    number: identity,
    null: identity,
    undefined(_) {
        return null;
    },
    string: identity,
};
function toJson(typeName, value) {
    if (!(typeName in ToJson))
        throw Error(`toJson: unsupported type "${typeName}"`);
    return ToJson[typeName](value);
}
function asFields(x) {
    return x.toFields();
}
function empty(_) {
    return [];
}
let ToFields = {
    PublicKey({ g }) {
        let { x, y } = g;
        // TODO inefficient! in-snark public key should be uncompressed
        let isOdd = y.toBits()[0];
        return [x, isOdd.toField()];
    },
    Field: asFields,
    Bool: asFields,
    AuthRequired(x) {
        return [x.constant, x.signatureNecessary, x.signatureSufficient]
            .map(asFields)
            .flat();
    },
    UInt32: asFields,
    UInt64: asFields,
    TokenId: asFields,
    Sign: asFields,
    // builtin
    number: empty,
    null: empty,
    undefined: empty,
    string: empty,
};
function toFields(typeName, value) {
    if (!(typeName in ToFields))
        throw Error(`toFields: unsupported type "${typeName}"`);
    return ToFields[typeName](value);
}
let toJsonLeafTypes = new Set(Object.keys(ToJson));
let toFieldsLeafTypes = new Set(Object.keys(ToFields));
function convertEventsToJson({ data }) {
    return data.map((row) => row.map((e) => toJson('Field', e)));
}
function convertEventsToFields({ hash }) {
    return [hash];
}
function convertStringWithHashToJson({ data }) {
    return data;
}
function convertStringWithHashToFields({ hash }) {
    return [hash];
}
