import { AsFieldElements } from '../snarky';
import { SmartContract } from './zkapp';
export { State, state, declareState };
/**
 * Gettable and settable state that can be checked for equality.
 */
declare type State<A> = {
    get(): A;
    set(a: A): void;
    fetch(): Promise<A | undefined>;
    assertEquals(a: A): void;
};
declare function State<A>(): State<A>;
/**
 * A decorator to use within a zkapp to indicate what will be stored on-chain.
 * For example, if you want to store a field element `some_state` in a zkapp,
 * you can use the following in the declaration of your zkapp:
 *
 * ```
 * @state(Field) some_state = State<Field>();
 * ```
 *
 */
declare function state<A>(stateType: AsFieldElements<A>): (target: SmartContract & {
    constructor: any;
}, key: string, _descriptor?: PropertyDescriptor | undefined) => void;
/**
 * `declareState` can be used in place of the `@state` decorator to declare on-chain state on a SmartContract.
 * It should be placed _after_ the class declaration.
 * Here is an example of declaring a state property `x` of type `Field`.
 * ```ts
 * class MyContract extends SmartContract {
 *   x = State<Field>();
 *   // ...
 * }
 * declareState(MyContract, { x: Field });
 * ```
 *
 * If you're using pure JS, it's _not_ possible to use the built-in class field syntax,
 * i.e. the following will _not_ work:
 *
 * ```js
 * // THIS IS WRONG IN JS!
 * class MyContract extends SmartContract {
 *   x = State();
 * }
 * declareState(MyContract, { x: Field });
 * ```
 *
 * Instead, add a constructor where you assign the property:
 * ```js
 * class MyContract extends SmartContract {
 *   constructor(x) {
 *     super();
 *     this.x = State();
 *   }
 * }
 * declareState(MyContract, { x: Field });
 * ```
 */
declare function declareState<T extends typeof SmartContract>(SmartContract: T, states: Record<string, AsFieldElements<unknown>>): void;
