import 'isomorphic-fetch';
import { Bool, Field, Types } from '../snarky';
import { UInt32, UInt64 } from './int';
import { Permissions } from './party';
import { PublicKey } from './signature';
export { fetchAccount, fetchLastBlock, parseFetchedAccount, markAccountToBeFetched, markNetworkToBeFetched, fetchMissingData, getCachedAccount, getCachedNetwork, addCachedAccount, defaultGraphqlEndpoint, setGraphqlEndpoint, sendZkappQuery, sendZkapp, };
export { Account };
declare let defaultGraphqlEndpoint: string;
declare function setGraphqlEndpoint(graphqlEndpoint: string): void;
/**
 * Gets account information on the specified publicKey by performing a GraphQL query
 * to the specified endpoint. This will call the 'GetAccountInfo' query which fetches
 * zkapp related account information.
 *
 * If an error is returned by the specified endpoint, an error is thrown. Otherwise,
 * the data is returned.
 *
 * @param publicKey The specified account to get account information on
 * @param graphqlEndpoint The graphql endpoint to fetch from
 * @param config An object that exposes an additional timeout option
 * @returns zkapp information on the specified account or an error is thrown
 */
declare function fetchAccount(publicKey: string | PublicKey, graphqlEndpoint?: string, { timeout }?: {
    timeout?: number | undefined;
}): Promise<{
    account: Account;
    error: undefined;
} | {
    account: undefined;
    error: FetchError;
}>;
declare type FetchResponse = {
    data: any;
};
declare type FetchError = {
    statusCode: number;
    statusText: string;
};
declare type AuthRequired = Types.Json.AuthRequired;
declare type FetchedAccount = {
    publicKey: string;
    nonce: string;
    zkappUri?: string;
    zkappState: string[] | null;
    receiptChainHash?: string;
    balance: {
        total: string;
    };
    permissions?: {
        editState: AuthRequired;
        send: AuthRequired;
        receive: AuthRequired;
        setDelegate: AuthRequired;
        setPermissions: AuthRequired;
        setVerificationKey: AuthRequired;
        setZkappUri: AuthRequired;
        editSequenceState: AuthRequired;
        setTokenSymbol: AuthRequired;
        incrementNonce: AuthRequired;
        setVotingFor: AuthRequired;
    };
    delegateAccount?: {
        publicKey: string;
    };
    sequenceEvents?: string[] | null;
};
declare type Account = {
    publicKey: PublicKey;
    nonce: UInt32;
    balance: UInt64;
    zkapp?: {
        appState: Field[];
    };
    permissions?: Permissions;
    receiptChainHash?: Field;
    delegate?: PublicKey;
    sequenceState?: Field;
    provedState?: Bool;
};
declare function parseFetchedAccount(account: FetchedAccount): Account;
declare function parseFetchedAccount(account: Partial<FetchedAccount>): Partial<Account>;
declare function markAccountToBeFetched(publicKey: PublicKey, graphqlEndpoint: string): void;
declare function markNetworkToBeFetched(graphqlEndpoint: string): void;
declare function fetchMissingData(graphqlEndpoint: string): Promise<void>;
declare function getCachedAccount(publicKey: PublicKey, graphqlEndpoint?: string): Account | undefined;
declare function getCachedNetwork(graphqlEndpoint?: string): {
    snarkedLedgerHash: Field;
    timestamp: UInt64;
    blockchainLength: UInt32;
    minWindowDensity: UInt32;
    totalCurrency: UInt64;
    globalSlotSinceHardFork: UInt32;
    globalSlotSinceGenesis: UInt32;
    stakingEpochData: {
        ledger: {
            hash: Field;
            totalCurrency: UInt64;
        };
        seed: Field;
        startCheckpoint: Field;
        lockCheckpoint: Field;
        epochLength: UInt32;
    };
    nextEpochData: {
        ledger: {
            hash: Field;
            totalCurrency: UInt64;
        };
        seed: Field;
        startCheckpoint: Field;
        lockCheckpoint: Field;
        epochLength: UInt32;
    };
};
declare function addCachedAccount(account: {
    publicKey: string | PublicKey;
    nonce: string | number | UInt32;
    balance?: string | number | UInt64;
    zkapp?: {
        appState: (string | number | Field)[];
    };
}, graphqlEndpoint?: string): void;
declare function fetchLastBlock(graphqlEndpoint?: string): Promise<{
    snarkedLedgerHash: Field;
    timestamp: UInt64;
    blockchainLength: UInt32;
    minWindowDensity: UInt32;
    totalCurrency: UInt64;
    globalSlotSinceHardFork: UInt32;
    globalSlotSinceGenesis: UInt32;
    stakingEpochData: {
        ledger: {
            hash: Field;
            totalCurrency: UInt64;
        };
        seed: Field;
        startCheckpoint: Field;
        lockCheckpoint: Field;
        epochLength: UInt32;
    };
    nextEpochData: {
        ledger: {
            hash: Field;
            totalCurrency: UInt64;
        };
        seed: Field;
        startCheckpoint: Field;
        lockCheckpoint: Field;
        epochLength: UInt32;
    };
}>;
declare function sendZkapp(json: string, graphqlEndpoint?: string, { timeout }?: {
    timeout?: number | undefined;
}): Promise<[FetchResponse, undefined] | [undefined, FetchError]>;
declare function sendZkappQuery(json: string): string;
