import { Field, AsFieldElements, Types } from '../snarky';
import { Party, Permissions, SetOrKeep } from './party';
import { PrivateKey, PublicKey } from './signature';
import { UInt32, UInt64 } from './int';
export { deploy, DeployArgs, signFeePayer, declareMethods };
/**
 * A decorator to use in a zkapp to mark a method as callable by anyone.
 * You can use inside your zkapp class as:
 *
 * ```
 * @method myMethod(someArg: Field) {
 *  // your code here
 * }
 * ```
 */
export declare function method<T extends SmartContract>(target: T & {
    constructor: any;
}, methodName: keyof T & string, descriptor: PropertyDescriptor): void;
declare type methodEntry<T> = {
    methodName: keyof T & string;
    witnessArgs: AsFieldElements<unknown>[];
    proofArgs: unknown[];
    args: {
        type: string;
        index: number;
    }[];
    witnessValues?: unknown[];
};
/**
 * A Statement consists of certain hashes of the transaction and of the proving Party which is constructed during method execution.

  In SmartContract.prove, a method is run twice: First outside the proof, to obtain the statement, and once in the prover,
  which takes the statement as input. The current transaction is hashed again inside the prover, which asserts that the result equals the input statement,
  as part of the snark circuit. The block producer will also hash the transaction they receive and pass it as a public input to the verifier.
  Thus, the transaction is fully constrained by the proof - the proof couldn't be used to attest to a different transaction.
 */
declare type Statement = Field[];
declare type Proof = unknown;
declare type Prover = (statement: Statement, previousStatements: Statement[]) => Promise<Proof>;
/**
 * The main zkapp class. To write a zkapp, extend this class as such:
 *
 * ```
 * class YourSmartContract extends SmartContract {
 *   // your smart contract code here
 * }
 * ```
 *
 */
export declare class SmartContract {
    address: PublicKey;
    private _executionState;
    static _methods?: methodEntry<SmartContract>[];
    static _provers?: Prover[];
    static _verificationKey?: {
        data: string;
        hash: Field;
    };
    constructor(address: PublicKey);
    static compile(address?: PublicKey): Promise<{
        verificationKey: {
            data: string;
            hash: string;
        };
        provers: ((statement: Field[], previousStatements: Field[][]) => Promise<unknown>)[];
        verify: (statement: Field[], proof: unknown) => Promise<boolean>;
    }>;
    deploy({ verificationKey, zkappKey, }: {
        verificationKey?: {
            data: string;
            hash: Field | string;
        };
        zkappKey?: PrivateKey;
    }): void;
    sign(zkappKey?: PrivateKey, fallbackToZeroNonce?: boolean): void;
    private executionState;
    get self(): Party;
    get account(): {
        nonce: {
            get(): UInt32;
            assertEquals(value: UInt32): void;
            assertNothing(): void;
        } & {
            assertBetween(lower: UInt32, upper: UInt32): void;
        };
        delegate: {
            get(): PublicKey;
            assertEquals(value: PublicKey): void;
            assertNothing(): void;
        };
        balance: {
            get(): UInt64;
            assertEquals(value: UInt64): void;
            assertNothing(): void;
        } & {
            assertBetween(lower: UInt64, upper: UInt64): void;
        };
        receiptChainHash: {
            get(): Field;
            assertEquals(value: Field): void;
            assertNothing(): void;
        };
        sequenceState: {
            neg: {};
            inv: {};
            add: {};
            sub: {};
            mul: {};
            div: {};
            square: {};
            sqrt: {};
            toString: {};
            toBigInt: {};
            toJSON: {};
            sizeInFields: {};
            toFields: {};
            lt: {};
            lte: {};
            gt: {};
            gte: {};
            assertLt: {};
            assertLte: {};
            assertGt: {};
            assertGte: {};
            assertEquals: {};
            assertBoolean: {};
            isZero: {};
            toBits: {};
            equals: {};
            seal: {};
            rangeCheckHelper: {};
            isConstant: {};
            toConstant: {};
            ofFields: {};
        };
        provedState: {
            get(): Types.Bool;
            assertEquals(value: Types.Bool): void;
            assertNothing(): void;
        };
    };
    get network(): {
        snarkedLedgerHash: {
            get(): Field;
            assertEquals(value: Field): void;
            assertNothing(): void;
        };
        timestamp: {
            get(): UInt64;
            assertEquals(value: UInt64): void;
            assertNothing(): void;
        } & {
            assertBetween(lower: UInt64, upper: UInt64): void;
        };
        blockchainLength: {
            get(): UInt32;
            assertEquals(value: UInt32): void;
            assertNothing(): void;
        } & {
            assertBetween(lower: UInt32, upper: UInt32): void;
        };
        minWindowDensity: {
            get(): UInt32;
            assertEquals(value: UInt32): void;
            assertNothing(): void;
        } & {
            assertBetween(lower: UInt32, upper: UInt32): void;
        };
        totalCurrency: {
            get(): UInt64;
            assertEquals(value: UInt64): void;
            assertNothing(): void;
        } & {
            assertBetween(lower: UInt64, upper: UInt64): void;
        };
        globalSlotSinceHardFork: {
            get(): UInt32;
            assertEquals(value: UInt32): void;
            assertNothing(): void;
        } & {
            assertBetween(lower: UInt32, upper: UInt32): void;
        };
        globalSlotSinceGenesis: {
            get(): UInt32;
            assertEquals(value: UInt32): void;
            assertNothing(): void;
        } & {
            assertBetween(lower: UInt32, upper: UInt32): void;
        };
        stakingEpochData: {
            ledger: {
                hash: {
                    get(): Field;
                    assertEquals(value: Field): void;
                    assertNothing(): void;
                };
                totalCurrency: {
                    get(): UInt64;
                    assertEquals(value: UInt64): void;
                    assertNothing(): void;
                } & {
                    assertBetween(lower: UInt64, upper: UInt64): void;
                };
            };
            seed: {
                get(): Field;
                assertEquals(value: Field): void;
                assertNothing(): void;
            };
            startCheckpoint: {
                get(): Field;
                assertEquals(value: Field): void;
                assertNothing(): void;
            };
            lockCheckpoint: {
                get(): Field;
                assertEquals(value: Field): void;
                assertNothing(): void;
            };
            epochLength: {
                get(): UInt32;
                assertEquals(value: UInt32): void;
                assertNothing(): void;
            } & {
                assertBetween(lower: UInt32, upper: UInt32): void;
            };
        };
        nextEpochData: {
            ledger: {
                hash: {
                    get(): Field;
                    assertEquals(value: Field): void;
                    assertNothing(): void;
                };
                totalCurrency: {
                    get(): UInt64;
                    assertEquals(value: UInt64): void;
                    assertNothing(): void;
                } & {
                    assertBetween(lower: UInt64, upper: UInt64): void;
                };
            };
            seed: {
                get(): Field;
                assertEquals(value: Field): void;
                assertNothing(): void;
            };
            startCheckpoint: {
                get(): Field;
                assertEquals(value: Field): void;
                assertNothing(): void;
            };
            lockCheckpoint: {
                get(): Field;
                assertEquals(value: Field): void;
                assertNothing(): void;
            };
            epochLength: {
                get(): UInt32;
                assertEquals(value: UInt32): void;
                assertNothing(): void;
            } & {
                assertBetween(lower: UInt32, upper: UInt32): void;
            };
        };
    };
    get balance(): {
        addInPlace(x: string | number | bigint | UInt32 | UInt64 | import("./int").Int64): void;
        subInPlace(x: string | number | bigint | UInt32 | UInt64 | import("./int").Int64): void;
    };
    get nonce(): UInt32;
    setValue<T>(maybeValue: SetOrKeep<T>, value: T): void;
    setPermissions(permissions: Permissions): void;
}
declare type DeployArgs = {
    verificationKey?: {
        data: string;
        hash: string | Field;
    };
    zkappKey?: PrivateKey;
};
declare function deploy<S extends typeof SmartContract>(SmartContract: S, { zkappKey, verificationKey, initialBalance, shouldSignFeePayer, feePayerKey, transactionFee, feePayerNonce, memo, }: {
    zkappKey: PrivateKey;
    verificationKey: {
        data: string;
        hash: string | Field;
    };
    initialBalance?: number | string;
    feePayerKey?: PrivateKey;
    shouldSignFeePayer?: boolean;
    transactionFee?: string | number;
    feePayerNonce?: string | number;
    memo?: string;
}): Promise<string>;
declare function signFeePayer(transactionJson: string, feePayerKey: PrivateKey | string, { transactionFee, feePayerNonce, memo: feePayerMemo, }: {
    transactionFee?: string | number | undefined;
    feePayerNonce?: string | number | undefined;
    memo?: string | undefined;
}): string;
/**
 * `declareMethods` can be used in place of the `@method` decorator
 * to declare SmartContract methods along with their list of arguments.
 * It should be placed _after_ the class declaration.
 * Here is an example of declaring a method `update`, which takes a single argument of type `Field`:
 * ```ts
 * class MyContract extends SmartContract {
 *   // ...
 *   update(x: Field) {
 *     // ...
 *   }
 * }
 * declareMethods(MyContract, { update: [Field] }); // `[Field]` is the list of arguments!
 * ```
 * Note that a method of the same name must still be defined on the class, just without the decorator.
 */
declare function declareMethods<T extends typeof SmartContract>(SmartContract: T, methodArguments: Record<string, AsFieldElements<unknown>[]>): void;
