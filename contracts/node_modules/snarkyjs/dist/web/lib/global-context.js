export { mainContext, withContext, withContextAsync, getContext, inProver, inCompile, inCheckedComputation, };
// context for compiling / proving
// TODO reconcile mainContext with currentTransaction
let mainContext = undefined;
function withContext({ witnesses = undefined, expectedAccesses = undefined, actualAccesses = 0, self, ...other }, f) {
    mainContext = { witnesses, expectedAccesses, actualAccesses, self, ...other };
    let result;
    try {
        result = f();
    }
    finally {
        mainContext = undefined;
    }
    return [self, result];
}
// TODO: this is unsafe, the mainContext will be overridden if we invoke this function multiple times concurrently
// at the moment, we solve this by detecting unsafe use and throwing an error
async function withContextAsync({ witnesses = undefined, expectedAccesses = 1, actualAccesses = 0, self, ...other }, f) {
    mainContext = { witnesses, expectedAccesses, actualAccesses, self, ...other };
    let result;
    try {
        result = await f();
        if (mainContext.actualAccesses !== mainContext.expectedAccesses)
            throw Error(contextConflictMessage);
    }
    finally {
        mainContext = undefined;
    }
    return [self, result];
}
let contextConflictMessage = "It seems you're running multiple provers concurrently within" +
    ' the same JavaScript thread, which, at the moment, is not supported and would lead to bugs.';
function getContext() {
    if (mainContext === undefined)
        throw Error(contextConflictMessage);
    mainContext.actualAccesses++;
    if (mainContext.expectedAccesses !== undefined &&
        mainContext.actualAccesses > mainContext.expectedAccesses)
        throw Error(contextConflictMessage);
    return mainContext;
}
function inProver() {
    return !!mainContext?.inProver;
}
function inCompile() {
    return !!mainContext?.inCompile;
}
function inCheckedComputation() {
    return !!mainContext?.inCompile || !!mainContext?.inProver;
}
