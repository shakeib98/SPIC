import 'reflect-metadata';
import { Field, Bool, JSONValue, AsFieldElements } from '../snarky';
export { asFieldElementsToConstant, CircuitValue, prop, arrayProp, matrixProp, public_, circuitMain, cloneCircuitValue, circuitValueEquals, circuitArray, };
declare type Constructor<T> = {
    new (...args: any[]): T;
};
declare function asFieldElementsToConstant<T>(typ: AsFieldElements<T>, t: T): T;
declare abstract class CircuitValue {
    static sizeInFields(): number;
    static toFields<T>(this: Constructor<T>, v: T): Field[];
    toFields(): Field[];
    toJSON(): JSONValue;
    equals(this: this, x: this): Bool;
    assertEquals(this: this, x: typeof this): void;
    static ofFields<T>(this: Constructor<T>, xs: Field[]): T;
    static toConstant<T>(this: Constructor<T>, t: T): T;
    static toJSON<T>(this: Constructor<T>, v: T): JSONValue;
    static fromJSON<T>(this: Constructor<T>, value: JSONValue): T | null;
}
declare function prop(this: any, target: any, key: string): void;
declare function circuitArray<T>(elementType: AsFieldElements<T>, length: number): {
    sizeInFields(): number;
    toFields(array: T[]): Field[];
    ofFields(fields: Field[]): T[];
    check(array: T[]): void;
};
declare function arrayProp<T>(elementType: AsFieldElements<T>, length: number): (target: any, key: string) => void;
declare function matrixProp<T>(elementType: AsFieldElements<T>, nRows: number, nColumns: number): (target: any, key: string) => void;
declare function public_(target: any, _key: string | symbol, index: number): void;
declare function circuitMain(target: any, propertyName: string, _descriptor?: PropertyDescriptor): any;
declare function cloneCircuitValue<T>(obj: T): T;
declare function circuitValueEquals<T>(a: T, b: T): boolean;
